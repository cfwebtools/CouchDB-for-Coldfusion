<!--- --------------------------------------------------------------------------------------- ----
	
Copyright (c) 2009, Russell Spivey (http://cfruss.blogspot.com)
All rights reserved.

Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:

    * Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
    * Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
    * Neither the name of the project nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	
---- --------------------------------------------------------------------------------------- --->


<!--- to make a view function work:
1. add a document to your database with an ID like: _design/myDocID (it must start with _design)
2. add a field titled, "language" with the value "coldfusion"
3. add a field titled, "views"
4. the value of the "views" field should contain map view functions in this format:
{
   "view1": {
       "map": "function view1(doc) { var result = structNew(); result.test = "view1"; emit("null", result);}"
   },
   "view2": {
       "map": "function view2(doc) { var result = structNew(); result.test = "view2"; emit("key", result);}"
   }
}

5. Then add some documents to test with and "Relax"!

View function requirements and notes:
- Functions in the same design/view cannot have the same name.
- Function names and their respective view names do not need to be the same.
- Functions must call emit(key,value) to add data to a view.
- If a document does not contain a field that a view function references, it will cause an error.
- If there is an error in one function, views for other functions will fail too.

Notes on errors:
- Errors generated by CouchDB are not easy to understand, and there is not very much help on the net! Sorry!
- Application.cfc is configured to return Coldfusion error messages to CouchDB. It logs detailed versions to: app_error.html
- If you get the error: "You must use unique function names for each view function", 
	you must reset the View Server using the reset method in this file. You can call it remotely: 
	http://localhost:8500/ your path to CouchDB for CF /view_server/view_server.cfc?method=switch&input=["reset"]
--->

<!--- this file is connected to CouchDB via a script that passes STDIN data to the "switch" method --->
<cfcomponent hint="Acts as the CouchDB view server (handles view requests)" output="false">
	<!--- ensure correct "stdout-style" formatting for method returns and output --->
	<cfsetting enablecfoutputonly="true">
	<cfcontent type="text/plain">
	
	
	<!--- init application variables (required for variable persistence over multiple couchDB requests) --->
	<cflock type="exclusive" scope="application" timeout="10">
		<cfparam name="application.functions" default="#arrayNew(1)#">
		<cfparam name="application.map_results" default="#arrayNew(1)#">
	</cflock>
	
	<cfset variables.functions = duplicate(application.functions)>
	
	
	<!--- switch --->
	<cffunction name="switch" access="remote" returntype="String" returnformat="plain" hint="Determines what to do with CouchDB request" >
		<cfargument name="input" type="String" required="true" hint="Input from CouchDB" />

		<cfset var result = ''>
		<cfset var input_array = ArrayNew(1)>
		<cfset var command = ''>

		<cfif arguments.input is ''>
			<cfthrow message="Invalid input from CouchDB: Received a blank string. Check your CouchDB to CF connector script for errors.">
		</cfif>
		
		<cfset input_array = deserializeJSON(urldecode(arguments.input))>

		<cfset command = lcase(input_array[1])>

		<!--- determine what to do based on command supplied by CouchDB --->
		<cfswitch expression="#command#">
			<cfcase value="reset">
				<cfinvoke method="reset" returnvariable="result">
			</cfcase>
			<cfcase value="add_fun">
				<cfinvoke method="add_fun" func="#input_array[2]#" returnvariable="result">
			</cfcase>
			<cfcase value="map_doc">
				<cfinvoke method="map_doc" document="#input_array[2]#" returnvariable="result">
			</cfcase>
			<cfcase value="reduce">
				<cfinvoke method="reduce" reduce_function="#input_array[2]#" map_doc_results="#input_array[3]#" returnvariable="result">
			</cfcase>
			<cfdefaultcase>
				<cfset result = false>
			</cfdefaultcase>
		</cfswitch>
		
		<cfreturn result & "#chr(10)#"/>
	</cffunction>


	<!--- reset --->
	<cffunction name="reset" access="private" returntype="boolean" hint="Resets the view server" >

		<cflock type="exclusive" scope="application" timeout="10">
			<cfset application.functions = ArrayNew(1)>
			<cfset application.map_results = arrayNew(1)>
		</cflock>

		<cfreturn true />
	</cffunction>


	<!--- add fun --->
	<!--- example input from CouchDB: 
		["add_fun","function asdas(doc){var result = structNew(); result.name = doc.name; result.newscore = doc.score * 5; emit(doc.name, result);}"] 
		--->
	<cffunction name="add_fun" access="private" returntype="String" hint="Adds a function to the view server">
		<cfargument name="func" type="String" required="true" hint="The function to add to the view server"  />
		
		<cfset var functions = variables.functions>
		<cfset var functions_cfc_string = ''>
		<cfset var new_array_len = arrayLen(functions) + 1>

		<!--- check for same-named function (this causes problems maybe?)--->
		<cfloop from="1" to="#arraylen(functions)#" index="i">
			<cfif functions[i].func_name is getFunctionName(arguments.func)>
				<cfthrow message="You must use unique function names for each view function." errorcode="add_fun_1">
			</cfif> 
		</cfloop>
		
		<!--- add new function to the array of function names and functions as strings --->
		<cfset functions[new_array_len] = structNew()>
		<cfset functions[new_array_len].func_name = getFunctionName(arguments.func)>
		<cfset functions[new_array_len].func_as_string = arguments.func>
		
		<!--- update application variable --->
		<cflock type="exclusive" scope="application" timeout="10">
			<cfset application.functions = functions>
		</cflock>
		
		<cfset variables.functions = functions>
		
		<!--- return true on success --->
		<cfreturn true />
	</cffunction>


	<!--- map doc --->
	<!--- example input from CouchDB: 
		["map_doc", {"_id":"9590AEB4585637FE","_rev":1674684684,"name":"Jane Clopterson","score": 43}]
		
		must return data in this format (with any number of arrays containing name/value pairs):
			[[["null",{"NAME":"VALUE","NAME":"VALUE"}]],[["null",{"NAME":"VALUE"}]]]
		--->
	<cffunction name="map_doc" access="private" returntype="String" hint="Parses all DB documents using the requested _design/document/views functions and returns the results to CouchDB for caching." >
		<cfargument name="document" type="Struct" required="true" hint="Document to map" />
		
		<cfset var func_result = ''>
		<cfset var result = arrayNew(1)>
		<cfset var array = ArrayNew(1)>
		<cfset var doc = arguments.document>
		<cfset var functions = variables.functions>
		<cfset var i = 1>

		<!--- loop over all view functions --->
		<cfloop from="1" to="#arrayLen(functions)#" index="i">
			
			<!--- send document to view function for parsing --->
			<cfinvoke component="#getFunctionsObject(functions)#" method="#functions[i].func_name#" doc="#doc#">
			
			<!--- view functions use emit() to place results into application.map_results --->
		</cfloop>
		
		<!--- serialize result --->
		<cfset result = serializeJSON(duplicate(application.map_results))>
		
		<cflock type="exclusive" scope="application" timeout="10">
			<cfset application.map_results = arrayNew(1)>
		</cflock>
		
		<!--- json fix: remove quotes around "null" --->
		<cfset result = replace(result,'"null"','null','all')>

		<cfreturn result />
	</cffunction>


	<!--- reduce --->
	<!--- 
		reduce_function example input: 
			["function reduce1(key, values, rereduce) { return sum(values);}"]
		map_doc_results example input: 
			[[[null,"fundoctest"],{"TEST":"something"}],[[null,"testdoc2"],{"TEST":"hmm"}]]
	--->
	<cffunction name="reduce" access="private" returntype="String" hint="TODO: explain this method">
		<cfargument name="reduce_function" type="array" required="true" hint="A function that performs calculations on map_doc results (in string format).">
		<cfargument name="map_doc_results" type="array" required="true" hint="Results of map_doc. JSON array in this format: [[key, id-of-doc], value]" />
		<cfargument name="rereduce" type="String" required="false" default="false">
		
		<cfset var result = ''>
		<cfset var i = 1>

		<cfset var keys = arrayNew(1)>
		<cfset var doc_ids = arrayNew(1)>
		<cfset var values_structs = arrayNew(1)>
		
		<!--- add reduce function --->
		<cfset add_fun(arguments.reduce_function[1])>

		<!--- get reduce function --->
		<cfset functions = variables.functions>
		
		<!--- prepare arrays of values as reduce function arguments --->
		<cfloop from="1" to="#(arrayLen(arguments.map_doc_results[1])/2)#" index="i">
			<cfset keys[i] = arguments.map_doc_results[1][i][1]>
			<cfset doc_ids[i] = arguments.map_doc_results[1][i][2]>
			<cfset values_structs[i] = arguments.map_doc_results[1][i+1]>
		</cfloop>
		
		<!--- call reduce function --->
		<cfinvoke component="#getFunctionsObject(functions)#" method="#functions[1].func_name#" key="#keys#" values="#values_structs#" rereduce="#arguments.rereduce#" returnvariable="reduce_result" />
		
		<!--- construct result --->
		<cfset result = arrayNew(1)>
		<cfset result[1] = "true">
		<cfset result[2] = arrayNew(1)>
		<cfset result[2][1] = reduce_result>
		
		<!--- serialize result --->
		<cfset result = serializeJSON(result)>
		
		<!--- json fix: remove quotes around "true" --->
		<cfset result = replace(result,'"true"','true','all')>

		<cfreturn result />
	</cffunction>


	<!--- rereduce --->
	<cffunction name="rereduce" access="private" returntype="void" hint="The same thing as reduce, but called recursively?">
		<cfargument name="map_results" type="String" required="true" hint="JSON array in this format: [[key, id-of-doc], value]" />
		<!--- TODO: Implement Method --->
		<cfthrow message="This method is not yet implemented">
		<cfreturn />
	</cffunction>


	<!--- couch log --->
	<cffunction name="couch_log" hint="Sends log information to CouchDB" access="private" returntype="void">
		<!--- TODO: Implement Method --->
		<cfthrow message="This method is not yet implemented">
		<cfreturn />
	</cffunction>
	
	
	<!--- MAP VIEW HELPER FUNCTIONS                                                   --->
	
	<!--- emit --->
	<!--- important note: 
			This function is called from view functions.
			View functions reside within a CFC that extends this CFC (view_server.cfc)
			--->
	<cffunction name="emit" returntype="void" hint="Called from within view functions">
		<cfargument name="key" type="String" required="false" default="null" hint="Key for document">
		<cfargument name="value" type="Any" required="true" hint="Results of map view function">
		
		<cfset var new_index = arrayLen(duplicate(application.map_results)) + 1>
		<cfset var array = ArrayNew(1)>
		<cfset var sub_array = ArrayNew(1)>
		
		<!--- if function returns a struct, assume success...--->
		<cfif isStruct(arguments.value)>
			<!--- construct an array within an array (because CouchDB wants it that way) --->
			<cfset sub_array[1] = arguments.key><!--- Map view key --->
			<cfset sub_array[2] = arguments.value><!--- Map view value struct (contains key/value pairs) --->
			<cfset array[1] = sub_array>
		</cfif>
		
		<cflock scope="application" type="exclusive" timeout="10">
			<cfset application.map_results[new_index] = array>
		</cflock>
	</cffunction>
	
	
	<!--- VIEW SERVER HELPER FUNCTIONS                                               --->
	
	<!--- Functions Object --->
	<cffunction name="getFunctionsObject" access="private" returntype="Any" hint="Returns a CFC object with variables.functions in it">
		<cfargument name="functions" type="Array" required="true" hint="Functions to be included in object. Array members must be structs with 'func_as_string' defined.">

		<cfset var functionsObject = ''>	
		<cfset var  i = 1>
		
		<!--- init vars for temporary CFC --->
		<cfset var rand = RandRange(1,100000)>
		<cfset var funcs_file = "view_server_funcs#rand#.cfc">
		<cfset var funcs_cfc = "view_server_funcs#rand#">
		<cfset var abs_path_to_funcs_file = expandpath(funcs_file)>

		<!--- clear runtime CFC cache 
			(this works, but you have to supply your RDS password. 
				 I'm using a randomly named CFC file instead.) --->
		<!---
		<cfset adminObj = createObject("component","cfide.adminapi.administrator").login("My RDS password")>
		<cfinvoke component="cfide.adminapi.runtime" method="clearTrustedCache" templateList="#abs_path_to_funcs_file#">
			 --->
		
		<!--- save tags as strings (CF will attempt to process them otherwise) --->
		<cfset cfcomponent_tag = "<cfcomponent extends='view_server'>">
		<cfset close_cfcomponent_tag = "</cfcomponent>">
		<cfset cfscript_tag = "<cfscript>">
		<cfset close_cfscript_tag = "</cfscript>">
		
		<!--- construct view_server_funcs.cfc --->
		<cfprocessingdirective suppressWhiteSpace="true">
			<cfsavecontent variable="functions_cfc_string">
				<cfoutput>
					#cfcomponent_tag#
					#cfscript_tag#
					#chr(13)#
					<cfloop from="1" to="#arrayLen(functions)#" index="i">
						#functions[i].func_as_string##chr(10)##chr(13)#
					</cfloop>
					#close_cfscript_tag#
					#close_cfcomponent_tag#
				</cfoutput>
			</cfsavecontent>
		</cfprocessingdirective>
		
		<!--- write functions cfc --->
		<cffile action="write" file="#abs_path_to_funcs_file#" output="#functions_cfc_string#" mode="777">

		<!--- compile functions cfc --->
		<cfset functionsObject = createObject("component", funcs_cfc)>
		
		<!--- delete functions cfc --->	
		<cffile action="delete" file="#abs_path_to_funcs_file#" />
		
		<cfreturn functionsObject>
	</cffunction>
	
	
	<!--- get function name --->
	<!--- hint: returns the function name from a cfscript function definition --->
	<cffunction name="getFunctionName" access="private">
		<cfargument name="str" type="string" required="true">
		<cfscript>
		    var test = REFindNoCase('(?:function\s+)(\w+)\s*(?:\()', arguments.str, 1, 1);
		    var pos = test.pos[2];
		    var len = test.len[2];
		    var result = mid(str,pos,len);
		
		    return result;
		</cfscript>
	</cffunction>
</cfcomponent>